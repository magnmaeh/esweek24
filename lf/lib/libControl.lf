target C

preamble {=
    #include <platform.h>

#if defined(PLATFORM_FLEXPRET)
    #define sleep_custom(x) do { \
        fp_wait_for(((x - 300) * USEC(1))); \
    } while(0)
#elif __linux__
    #include <unistd.h>
    #define sleep_custom(x) do { \
        usleep((x - 150)); \
    } while(0)
#elif defined(PLATFORM_ZEPHYR)
    #include <zephyr/kernel.h>
    #define sleep_custom(x) do { \
        k_sleep(K_USEC(x)); \
    } while(0)
#elif defined(PLATFORM_RP2040)
    #include <hardware/timer.h>
    #define sleep_custom(x) do { \
        busy_wait_us_32(x); \
    } while(0)
#endif
=}

reactor Logger(n_iterations: int = 10) {
    input ts_sensor: instant_t
    input ts_process: instant_t
    input ts_actuator: instant_t

    state iteration: int = 0
    state ts: instant_t*

    reaction(startup) {=
        self->ts = malloc(3 * self->n_iterations * sizeof(instant_t));
    =}

    reaction(ts_sensor) {=
        self->ts[self->iteration++] = ts_sensor->value;
    =}

    reaction(ts_process) {=
        self->ts[self->iteration++] = ts_process->value;
    =}

    reaction(ts_actuator) {=
        self->ts[self->iteration++] = ts_actuator->value;
    =}

    reaction(shutdown) {=
        printf("logger shutdown\n");
        for (int i = 0; i < self->n_iterations; i++) {
#if defined(PLATFORM_FLEXPRET)
            fp_print_int(i);
            fp_print_string("Sampled: ");
            fp_print_int(self->ts[3 * i + 0]);
            fp_print_string("Processed: ");
            fp_print_int(self->ts[3 * i + 1]);
            fp_print_string("Actuated: ");
            fp_print_int(self->ts[3 * i + 2]);

            //printf("[%i]: sampled: %lli, processed: %lli, actuated: %lli\n",
            //    i,
            //    self->ts[3 * i + 0],
            //    self->ts[3 * i + 1],
            //    self->ts[3 * i + 2]
            //);
#elif __linux__ || defined(PLATFORM_ZEPHYR)
            printf("[%i]: sampled: %lli, processed: %lli, actuated: %lli\n",
                i,
                self->ts[3 * i + 0],
                self->ts[3 * i + 1],
                self->ts[3 * i + 2]
            );
#elif defined(PLATFORM_RP2040)
            printf_custom("[%i]: sampled: %lli, processed: %lli, actuated: %lli\n",
                i,
                self->ts[3 * i + 0],
                self->ts[3 * i + 1],
                self->ts[3 * i + 2]
            );
#endif
        }
        free(self->ts);
    =}
}

reactor Sensor(n_iterations: int = 10) {
    output y: int
    output ts: instant_t

    state it: int = 0
    timer t(50 msec, 10 msec)

    state data: uint16_t[] = {=
        {
#include "/tmp/normal.txt"
        };
    =}

    reaction(t) -> y, ts {=
        lf_set(y, self->data[self->it++]);
        lf_set(ts, lf_time_physical() - lf_time_logical());
#if defined(PLATFORM_FLEXPRET)
        fp_print_string("\n");
#elif __linux__ || defined(PLATFORM_ZEPHYR)
        printf("\n");
#elif defined(PLATFORM_RP2040)
        printf_custom("\n");
#endif
    =}
}

reactor ProcessUnbounded {
    input x: int
    output y: int
    output ts: instant_t

    reaction(x) -> y, ts {=
        // "Process" for value time, this introduces jitter
        sleep_custom(x->value);


        lf_set(y, x->value);
        lf_set(ts, lf_time_physical() - lf_time_logical());
    =}
}

reactor Actuator(n_iterations: int = 10) {
    input x: int
    output ts: instant_t

    state it: int = 0

    reaction(x) -> ts {=
        lf_set(ts, lf_time_physical() - lf_time_logical());

        // Actuate with x
        if (++self->it == self->n_iterations) {
            extern bool should_print;
            extern bool int_service_active;
            
            should_print       = false;
            int_service_active = false;
            
            printf("Stop after %i iterations\n", self->it);
            lf_request_stop();
        }
    =}
}
